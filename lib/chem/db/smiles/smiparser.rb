#
# DO NOT MODIFY!!!!
# This file is automatically generated by racc 1.4.4
# from racc grammer file "smiles.ry".
#

require 'racc/parser'


class SmilesParser < Racc::Parser

module_eval <<'..end smiles.ry modeval..idae4de8f30f', 'smiles.ry', 84

def next_token
  @q.shift
end

def construct mol, tree, prev = nil
  tree.each do |node|
    if node.instance_of?(Array)
      construct(mol, node, prev)
    else
      mol.nodes.push(node)
      mol.join(prev, node) if prev
      if node.smiles_pos
        node.smiles_pos.each do |sp|
          if @ring[sp]
            mol.join(node, @ring[sp])
            # re-use ring closure digits
            # Higher-numbered ring closures are not supported yet.
            @ring[sp] = nil
          else
            @ring[sp] = node
          end
        end
      end
      prev = node
    end
  end
end

def initialize
  super
  @ring = []
end

def self.parse_smiles( smiles )
  SmilesParser.new.parse( smiles)
end

ElementRegex   = Regexp.new('\A(Cl|Br|B|C|N|O|P|S|F|I|H)', Regexp::IGNORECASE)
InorganicRegex = /\A\[([^\]]+)\]/
NumberRegex    = /\A\d+/
BackSlashRegex = /\\/
OtherRegex     = /\A./

def parse( line )
  @q = []
  
  line.strip!
  until line.empty? do
    case line
    when InorganicRegex
      # [nH] : aromatic N-H
      @q.push [:ATOM_SYMBOL, $&] # [m[1], m[2], m[3], m[4], m[5], m[6]]]
    when ElementRegex
      prop = {}
      prop[:is_aromatic] = (97 <= $&[0]) #and 122 < $&[0]
      @q.push [:SYMBOL, [$&.capitalize.intern , prop]]
    when NumberRegex
      @q.push [:NUMBER, $& ]
    when BackSlashRegex
      @q.push [:BSLASH, :BSLASH]
    when OtherRegex
      @q.push [$&, $&]
    else
      raise RuntimeError, 'must not happen'
    end
    line = $'
  end
  @q.push [ :EOL, nil ]
  mol = Chem::SmilesMol.new
  construct(mol, do_parse)
  mol
end

..end smiles.ry modeval..idae4de8f30f

##### racc 1.4.4 generates ###

racc_reduce_table = [
 0, 0, :racc_error,
 0, 16, :_reduce_none,
 3, 16, :_reduce_2,
 1, 17, :_reduce_3,
 2, 17, :_reduce_4,
 1, 18, :_reduce_none,
 2, 18, :_reduce_6,
 1, 18, :_reduce_none,
 1, 22, :_reduce_8,
 1, 22, :_reduce_9,
 1, 19, :_reduce_none,
 2, 19, :_reduce_11,
 1, 20, :_reduce_none,
 1, 20, :_reduce_none,
 1, 20, :_reduce_none,
 1, 20, :_reduce_none,
 1, 20, :_reduce_none,
 1, 20, :_reduce_none,
 1, 20, :_reduce_none,
 3, 21, :_reduce_19 ]

racc_reduce_n = 20

racc_shift_n = 26

racc_action_table = [
     4,     7,     8,     7,     8,    19,     9,    11,    13,    15,
    17,     2,     5,     6,    22,     7,     8,    20,     9,    11,
    13,    15,    17,     2,     5,     6,     7,     8,   nil,     9,
    11,    13,    15,    17,     2,     5,     6,    25,     7,     8,
   nil,     9,    11,    13,    15,    17,     2,     5,     6 ]

racc_action_check = [
     1,    16,    16,     1,     1,     3,     1,     1,     1,     1,
     1,     1,     1,     1,    10,    10,    10,     4,    10,    10,
    10,    10,    10,    10,    10,    10,    21,    21,   nil,    21,
    21,    21,    21,    21,    21,    21,    21,    21,     6,     6,
   nil,     6,     6,     6,     6,     6,     6,     6,     6 ]

racc_action_pointer = [
   nil,     0,   nil,     0,    17,   nil,    35,   nil,   nil,   nil,
    12,   nil,   nil,   nil,   nil,   nil,    -2,   nil,   nil,   nil,
   nil,    23,   nil,   nil,   nil,   nil ]

racc_action_default = [
    -1,   -20,   -17,   -10,   -20,   -18,   -20,    -8,    -9,   -12,
   -20,   -13,    -3,   -14,    -5,   -15,   -20,   -16,    -7,   -11,
    26,   -20,    -2,    -4,    -6,   -19 ]

racc_goto_table = [
    23,    10,     1,    24,   nil,   nil,    21,   nil,   nil,   nil,
   nil,    23 ]

racc_goto_check = [
     3,     2,     1,     4,   nil,   nil,     2,   nil,   nil,   nil,
   nil,     3 ]

racc_goto_pointer = [
   nil,     2,     0,   -10,   -13,   nil,   nil,   nil ]

racc_goto_default = [
   nil,   nil,   nil,    12,    14,    16,    18,     3 ]

racc_token_table = {
 false => 0,
 Object.new => 1,
 :EOL => 2,
 :SYMBOL => 3,
 :ATOM_SYMBOL => 4,
 :NUMBER => 5,
 "-" => 6,
 "=" => 7,
 "#" => 8,
 ":" => 9,
 "/" => 10,
 :BSLASH => 11,
 "." => 12,
 "(" => 13,
 ")" => 14 }

racc_use_result_var = true

racc_nt_base = 15

Racc_arg = [
 racc_action_table,
 racc_action_check,
 racc_action_default,
 racc_action_pointer,
 racc_goto_table,
 racc_goto_check,
 racc_goto_default,
 racc_goto_pointer,
 racc_nt_base,
 racc_reduce_table,
 racc_token_table,
 racc_shift_n,
 racc_reduce_n,
 racc_use_result_var ]

Racc_token_to_s_table = [
'$end',
'error',
'EOL',
'SYMBOL',
'ATOM_SYMBOL',
'NUMBER',
'"-"',
'"="',
'"#"',
'":"',
'"/"',
'BSLASH',
'"."',
'"("',
'")"',
'$start',
'smiles',
'smile',
'node',
'atom_pos',
'bond',
'branch',
'atom']

Racc_debug_parser = false

##### racc system variables end #####

 # reduce 0 omitted

 # reduce 1 omitted

module_eval <<'.,.,', 'smiles.ry', 9
  def _reduce_2( val, _values, result )
                   return val[1]
   result
  end
.,.,

module_eval <<'.,.,', 'smiles.ry', 13
  def _reduce_3( val, _values, result )
                   result = val
   result
  end
.,.,

module_eval <<'.,.,', 'smiles.ry', 17
  def _reduce_4( val, _values, result )
                   result.push(val[1])
   result
  end
.,.,

 # reduce 5 omitted

module_eval <<'.,.,', 'smiles.ry', 23
  def _reduce_6( val, _values, result )
                   val[1].bond = val[0]
                   result = val[1]
   result
  end
.,.,

 # reduce 7 omitted

module_eval <<'.,.,', 'smiles.ry', 31
  def _reduce_8( val, _values, result )
                   node = Chem::SmilesAtom.new
                   node.element = val[0][0]
                   node.is_aromatic = val[0][1][:is_aromatic]
                   result = node
   result
  end
.,.,

module_eval <<'.,.,', 'smiles.ry', 54
  def _reduce_9( val, _values, result )
                   m = /(\d*)([A-Za-z][a-z]?)(@*)(H\d*)?(\d*[+-]+)?/.match(val[0])
#                   m = /(\d*)([A-Za-z][a-z]?)(@*)(H?\d*)(-?\d*)?/.match(val[0])
                   node = Chem::SmilesAtom.new
                   node.mass           = m[1].to_i
                   node.element        = m[2].capitalize.intern
                   node.is_aromatic    = (97 <= m[2][0]) #and 122 < $&[0]
                   node.chiral         = m[3]

                   if m[4] and not m[4] == ""
                     hydrogen = /H(\d)+/.match(m[4])
                     node.hydrogen_count = hydrogen ? hydrogen[1].to_i : 1
                   end
                   if m[5]
                     charge = /(\d*)([+-]+)/.match(m[5])
                     sign   = (charge[2][0..0] == "+") ? 1 : -1
                     n      = charge[1] == "" ? charge[2].length : charge[1].to_i
                     node.charge = sign * n
                   end

                   result              = node
   result
  end
.,.,

 # reduce 10 omitted

module_eval <<'.,.,', 'smiles.ry', 60
  def _reduce_11( val, _values, result )
                   val[0].smiles_pos = val[1].split("").collect{|c| c.to_i}
                   result = val[0]
   result
  end
.,.,

 # reduce 12 omitted

 # reduce 13 omitted

 # reduce 14 omitted

 # reduce 15 omitted

 # reduce 16 omitted

 # reduce 17 omitted

 # reduce 18 omitted

module_eval <<'.,.,', 'smiles.ry', 71
  def _reduce_19( val, _values, result )
                   result = val[1]
   result
  end
.,.,

 def _reduce_none( val, _values, result )
  result
 end

end   # class SmilesParser


module Chem
  
  class SmilesAtom
    include Atom
    attr_accessor :bond, :element, :element, :chiral, :hydrogen_count, :charge, :is_aromatic, :smiles_pos

    def inspect
      "{%s %s(%s)}" % [@bond, @element, smiles_pos ? smiles_pos.join("-") : ""]
    end

  end
  
  class SmilesBond
    include Bond
  end

  class SmilesMol
    
    include Molecule
    include Enumerable

    attr_reader :nodes, :edges

    def initialize
      @nodes = []
      @edges = []
    end
    
    def join from, to
      return if to.bond == '.'
      bond = SmilesBond.new

      bond.v = case to.bond
               when '='
                 2
               when '#'
                 3
               else
                 1
               end
      @edges.push([bond, from, to])
    end

  end

end
